The MIL interpreter assumes the following about a MIL program:

1. Each line in the MIL file contains at most one MIL instruction
2. Each line is at most 254 characters long
3. All variables are defined before they are used
4. Functions begin with a line of the form "func name" and end with the line "endfunc"

Functions in the MIL language:

Functions in the MIL language start with a line of the form "func name" and end with the line "endfunc".
Parameters are passed to mil functions with the param command, and values are returned from functions.
Inside functions, arguments are referenced using a positional notation.
For example, the first argument specified with the param instruction prior to the current function call would be accessible as the name $0.
All arguments are passed by value, and recursive function calls are supported.
A semantically valid MIL program must contain a function named main.
All functions (with the exception of main) must return a scalar value.
The main function must not return any value.

#----------------------------------------

COMPLETED TASKS

integer ( negative/zero/positive )
arrays  ( size >= 1 ... not sure how would handle empty ? )

DECLARE
    declare integer
    declare integers in a list
    declare array of integer
READ
    read integer
    read integers in a list
    // read array
WRITE
    write integer
    write integers in a list
    // write array
ASSIGN
    assign number to integer

#----------------------------------------

some of the rules are printing out weird/backwards/postfix because of the precedence

eventually probably will comment out the part to print names of ids in identifier rule since should have that fixed for each rule.
eventually probably will comment out the part to print numbers in term rule since should have that fixed for each rule.

have not figured out to do labels or jumping with branches and loops

reads/writes with integers work
not sure how to tell if working when read/write to array has to check type and decide
it should work but it looks like its actually broken because writes/reads with arrays cause segfaults

the "=" is used in statement for ASSIGN, and maybe var or elsewhere because of the temporary variables created.
if assign is "id := expr" then expression can be complex but returns an int

so far most of the hard work is in the rules "function" and "declaration" and "identifer/identifierF"

    when multiple identifiers declared on one line then multiple "." is generated later in a loop after names are collected.
        i, j : integer;

    names are collected in identifier and when that returns to declaration they are added to symtab if not yet in.
    adding to symbol table in the declaration part something like
        symtab[*yylval.sval] = "0";
        symtab[*yylval.sval] = "n"; where n is # of elements

    add an identifierF for functions so they dont get names added to symbol table
    this is used where an identifer name is for a function
        in the function rule
        in term rule for function calls

#----------------------------------------

DATAS:

vector<string> rwvarslst;
    read/write list
    strings get appended in var rule. appends for READ, WRITE, and also ASSIGN
    clear in statement -> ASSIGN to get rid of accidental var appends ?
    clear in term -> var to get rid of accidental var appends ?
    clear in read/write after loop
    clear in function after scope

vector<string> idslst;
    id declare list
    strings get appended in identifier rule
    clear in declaration after loop
    clear in function after scope

map<string,string> symtab;
    function symbol table
    clear in declaration after loop
    clear in function after scope