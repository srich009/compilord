The MIL interpreter assumes the following about a MIL program:

1. Each line in the MIL file contains at most one MIL instruction
2. Each line is at most 254 characters long
3. All variables are defined before they are used
4. Functions begin with a line of the form "func name" and end with the line "endfunc"

Functions in the MIL language:

Functions in the MIL language start with a line of the form "func name" and end with the line "endfunc".
Parameters are passed to mil functions with the param command, and values are returned from functions.
Inside functions, arguments are referenced using a positional notation.
For example, the first argument specified with the param instruction prior to the current function call would be accessible as the name $0.
All arguments are passed by value, and recursive function calls are supported.
A semantically valid MIL program must contain a function named main.
All functions (with the exception of main) must return a scalar value.
The main function must not return any value.

#----------------------------------------

COMPLETED TASKS

integer ( negative/zero/positive )
arrays  ( size >= 1 )

DECLARE
    declare integer
    declare integers in a list
    declare array of integer
READ
    read integer
    read integers in a list
    read array
WRITE
    write integer
    write integers in a list
    write array
ASSIGN
    assign number to integer
    // ...
ARITHMETIC
    // ...

#----------------------------------------

* misc
    some of the rules are printing out weird/backwards/postfix because of the precedence

    eventually probably will comment out the part to print names of ids in identifier rule since should have that fixed for each rule.
    eventually probably will comment out the part to print numbers in term rule since should have that fixed for each rule.

* branch, loops, jump, label
    have not figured out to do labels or jumping with branches and loops
    also need the bool stuff to work first

* booleans
    not done at all yet

* arithmetic
    need to have assignment working first before can do math

* assignment
    the "=" is used in statement for ASSIGN, and maybe var or elsewhere because of the temporary variables created.
    have to figure out when = vs []= or =[], have to check the type before
    if assign is "id := expr" then any expression can be complex but eventually returns an int
    

* read/write
    form of "read/write vars" for the pattern
    when it goes to var rule then ids are added to the rwvarslst vector.
    when in read/write has to check type and decide int or array
    then in loop the mil is output (similar to the declaration rule)
    this works for integers, in var rule the id name is in yylval.sval is appended to rwvarslst,
    it work for arrays but for arrays it is more complicated because of syntax, have to get the last id in the idslst and append to rwvarslst
    with arrays the yylval.ival is the index to read/write

* declarations/identifiers
    so far the code is in and "declaration" and "identifer/identifierF"

    when multiple identifiers declared on one line then multiple "." is generated for each id later in a loop after names are collected.
        i, j : integer;

    names are collected in identifier the strings are put into idslst vector
    when that part returns to the declaration a loop will add ids to symtab if not yet in.
    then the mil code is output in the same loop

    adding to symbol table in the declaration part with a loop something like
        symtab[*yylval.sval] = "0";
        symtab[*yylval.sval] = to_string(yylval.ival); // yylval.ival is # of elements

    note because of the way distinguish between scalar and array with scalar size == 0
    there can be no empty arrays, ie. arrays must be size >= 1

    add an identifierF for functions so they dont get names added to symbol table
    this is used where an identifer name is for a function
        in the function rule
        in term rule for function calls

* functions
    each rule should write to the string stream then when done goes to function rule
    in function rule output: "func", ss.str(), and "endfunc"
    save output to vector of strings where each string is the mil code for a function
    after output reset ss.str() to "" and clear the stringstream
    also save symbol table to vector of maps

#----------------------------------------

DATAS:

vector<string> rwvarslst;
    read/write list
    strings get appended in var rule. appends for READ, WRITE, and also ASSIGN
    clear in statement -> ASSIGN to get rid of accidental var appends ?
    clear in term -> var to get rid of accidental var appends ?
    clear in read/write after loop
    clear in function after scope

vector<string> idslst;
    id declare list
    strings get appended in identifier rule
    clear in declaration after loop
    clear in function after scope

map<string,string> symtab;
    function symbol table
    clear in declaration after loop
    clear in function after scope

